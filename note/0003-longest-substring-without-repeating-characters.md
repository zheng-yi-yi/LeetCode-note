# 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

 **示例 1:**

```bash
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```bash
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```bash
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、数字、符号和空格组成

---

# 解题

这道题可以用**滑动窗口**的思想来做。

## 什么是滑动窗口？

滑动窗口（Sliding Window）是一种常用于解决字符串或数组中子串（子数组）相关问题的算法技巧。

它通过定义一个窗口（通常是一个连续的子串或子数组），然后在该窗口内执行操作，不断滑动这个窗口，以便找到特定条件的解决方案。这个窗口会根据问题的要求不断扩展、缩小或移动，以达到问题的解决目标。

滑动窗口的一般步骤包括：

1. 定义窗口的左右边界：通常用两个指针来表示窗口的左边界和右边界，初始时它们可能在数组或字符串的开头。
2. 初始窗口状态：根据问题的要求，你可能需要初始化一些变量或数据结构来记录窗口内的信息。
3. 开始滑动：通过右边界的移动来扩展窗口，或者通过左边界的移动来缩小窗口。移动的方式取决于问题的要求。
4. 在窗口内执行操作：在每个窗口位置，执行特定的操作，通常是计算、检查或更新窗口内的信息。
5. 满足条件时更新结果：如果满足问题的条件，根据问题要求更新结果。这可以是找到子串的最小长度、最大长度、最大和、最小和，或其他与问题相关的内容。
6. 继续滑动：继续移动窗口，重复步骤 3 和 4，直到遍历完整个输入数据。
7. 返回结果：在整个过程完成后，返回得到的结果。

## 解题代码

我们说回这道题。

```java
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    if (n == 0) {
        return 0; // 如果字符串为空，最长子串长度为0
    }

    int[] charIndex = new int[1024]; // 用于存储字符在字符串中的最后一个出现的位置
    int maxLength = 0; // 用于记录最长子串的长度
    int left = 0; // 左边界指针

    for (int right = 0; right <= n-1; right++) {
        char currentChar = s.charAt(right); // 当前循环中遍历到的字符（基础）

        // 如果当前字符已经在窗口中出现过，更新左边界为上次出现位置的下一个位置（核心）
        if (charIndex[currentChar] > left) {
            left = charIndex[currentChar];
        }

        // 更新字符的最后一个出现位置（关键）
        charIndex[currentChar] = right + 1;

        // 计算当前窗口的长度
        int currentLength = right - left + 1;  // （目的）

        // 更新最大子串长度
        maxLength = Math.max(maxLength, currentLength);
    }

    return maxLength;
}
```

解题思路如下：

遍历整个字符串 `s`，其中 `left` 是左边界指针， `right` 是右边界指针。并且 `right` 是从 0 开始逐渐增加，直到 `n-1`。

在每一层for循环中：

1. 对于每个字符 `currentChar`，执行以下步骤：

   - 如果 `currentChar` 已经在窗口中出现过，意味着发现了重复字符，那么更新左指针变量 `left` ，以确保当前窗口内没有重复字符。

   - 更新当前字符的最后一次出现位置的下一个位置，即 `charIndex[currentChar]` 为 `right + 1`。

2. 处理完字符后，我们再来计算窗口大小（也就是连续无重复字符的最长子串长度）

   - 首先计算当前窗口长度`currentLength`，即 `right - left + 1`
   - 接着，更新 `maxLength` 为 `Math.max(maxLength, currentLength)`，以确保 `maxLength` 存储了最长的不含重复字符的子串长度。

最后返回 `maxLength`，即最长不含重复字符的子串的长度。

## 总结

上述解题的算法核心，就是通过维护一个滑动窗口（由 `left` 和 `right` 指针定义），不断更新窗口的左边界和右边界，以保证窗口内的字符都是不重复的。通过这个方法，可以在线性时间复杂度内找到最长不含重复字符的子串。